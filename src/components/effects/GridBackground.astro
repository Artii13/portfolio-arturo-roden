---
// GridBackground Component - 3D Parallax Grid Effect
---

<div id="grid-background" class="grid-container">
  <canvas id="grid-canvas"></canvas>
</div>

<style>
  .grid-container {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    z-index: -1;
    pointer-events: none;
    will-change: transform;
    perspective: 1000px;
  }
  
  #grid-canvas {
    width: 100%;
    height: 100%;
    will-change: transform;
    transform-style: preserve-3d;
  }
</style>

<script is:inline>
(function() {
  // Esperar a que el DOM esté listo
  document.addEventListener('DOMContentLoaded', function() {
    const canvas = document.getElementById('grid-canvas');
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    let width, height;
    let mouseX = 0.5;
    let mouseY = 0.5;
    let targetMouseX = 0.5;
    let targetMouseY = 0.5;
    let gridOpacity = 0.08;
    let gridColor = { r: 42, g: 42, b: 42 }; // #2A2A2A
    let targetGridColor = { r: 42, g: 42, b: 42 };
    let isLightMode = true;
    
    // Configuración del grid
    const gridSize = 60;
    const dotRadius = 1.5;
    
    function resize() {
      const dpr = window.devicePixelRatio || 1;
      width = window.innerWidth;
      height = window.innerHeight;
      canvas.width = width * dpr;
      canvas.height = height * dpr;
      canvas.style.width = width + 'px';
      canvas.style.height = height + 'px';
      ctx.scale(dpr, dpr);
    }
    
    function lerp(a, b, t) {
      return a + (b - a) * t;
    }
    
    function draw() {
      // Limpiar canvas
      ctx.clearRect(0, 0, width, height);
      
      // Suavizar movimiento del mouse
      mouseX = lerp(mouseX, targetMouseX, 0.05);
      mouseY = lerp(mouseY, targetMouseY, 0.05);
      
      // Suavizar transición de color
      gridColor.r = lerp(gridColor.r, targetGridColor.r, 0.03);
      gridColor.g = lerp(gridColor.g, targetGridColor.g, 0.03);
      gridColor.b = lerp(gridColor.b, targetGridColor.b, 0.03);
      
      // Calcular rotación 3D basada en posición del mouse
      const rotateX = (mouseY - 0.5) * 8; // -4 a 4 grados
      const rotateY = (mouseX - 0.5) * 8; // -4 a 4 grados
      
      // Aplicar transformación 3D al canvas
      canvas.style.transform = `rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;
      
      // Calcular offset de parallax
      const offsetX = (mouseX - 0.5) * 20;
      const offsetY = (mouseY - 0.5) * 20;
      
      // Dibujar grid de puntos
      ctx.fillStyle = `rgba(${Math.round(gridColor.r)}, ${Math.round(gridColor.g)}, ${Math.round(gridColor.b)}, ${gridOpacity})`;
      
      const cols = Math.ceil(width / gridSize) + 2;
      const rows = Math.ceil(height / gridSize) + 2;
      
      for (let i = -1; i < cols; i++) {
        for (let j = -1; j < rows; j++) {
          const x = i * gridSize + offsetX;
          const y = j * gridSize + offsetY;
          
          // Efecto de profundidad sutil
          const distFromCenter = Math.sqrt(
            Math.pow((x / width) - 0.5, 2) + 
            Math.pow((y / height) - 0.5, 2)
          );
          const depthScale = 1 - distFromCenter * 0.2;
          
          ctx.beginPath();
          ctx.arc(x, y, dotRadius * depthScale, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // Dibujar líneas horizontales sutiles
      ctx.strokeStyle = `rgba(${Math.round(gridColor.r)}, ${Math.round(gridColor.g)}, ${Math.round(gridColor.b)}, ${gridOpacity * 0.5})`;
      ctx.lineWidth = 0.5;
      
      for (let j = 0; j < rows; j++) {
        const y = j * gridSize + offsetY;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }
      
      // Dibujar líneas verticales sutiles
      for (let i = 0; i < cols; i++) {
        const x = i * gridSize + offsetX;
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, height);
        ctx.stroke();
      }
      
      requestAnimationFrame(draw);
    }
    
    // Mouse move handler con throttle
    let mouseMoveTimeout;
    document.addEventListener('mousemove', function(e) {
      if (mouseMoveTimeout) return;
      mouseMoveTimeout = setTimeout(function() {
        targetMouseX = e.clientX / window.innerWidth;
        targetMouseY = e.clientY / window.innerHeight;
        mouseMoveTimeout = null;
      }, 16); // ~60fps
    });
    
    // Función para cambiar modo (llamada desde animations.js)
    window.setGridMode = function(mode) {
      if (mode === 'dark') {
        targetGridColor = { r: 245, g: 245, b: 220 }; // #F5F5DC
        gridOpacity = 0.06;
        isLightMode = false;
      } else {
        targetGridColor = { r: 42, g: 42, b: 42 }; // #2A2A2A
        gridOpacity = 0.08;
        isLightMode = true;
      }
    };
    
    // Función para interpolar el modo del grid
    window.setGridProgress = function(progress) {
      // progress: 0 = light, 1 = dark
      const lightColor = { r: 42, g: 42, b: 42 };
      const darkColor = { r: 245, g: 245, b: 220 };
      
      targetGridColor.r = lerp(lightColor.r, darkColor.r, progress);
      targetGridColor.g = lerp(lightColor.g, darkColor.g, progress);
      targetGridColor.b = lerp(lightColor.b, darkColor.b, progress);
      gridOpacity = lerp(0.08, 0.06, progress);
    };
    
    // Inicializar
    resize();
    window.addEventListener('resize', resize);
    draw();
  });
})();
</script>

